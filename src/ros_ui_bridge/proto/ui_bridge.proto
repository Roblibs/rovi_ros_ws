syntax = "proto3";

package roblibs.ui_bridge.v1;

service UiBridge {
  // Returns a single status snapshot (includes metadata).
  rpc GetStatus(StatusRequest) returns (StatusSnapshot);

  // Streams status updates (values only; no metadata).
  rpc StreamStatus(StatusRequest) returns (stream StatusUpdate);

  // Streams robot pose + wheel joint angles for 3D rendering.
  rpc StreamRobotState(RobotStateRequest) returns (stream RobotStateUpdate);

  // Streams downsampled lidar scans for 3D visualization.
  rpc StreamLidar(LidarRequest) returns (stream LidarUpdate);

  // Streams an encoded occupancy grid map suitable for UI rendering.
  rpc StreamMap(MapRequest) returns (stream MapUpdate);

  // Returns metadata for the current robot model (no GLB bytes).
  rpc GetRobotModelMeta(RobotModelRequest) returns (RobotModelMeta);

  // Returns the robot model as a GLB (binary glTF) stream (chunked to avoid gRPC message size limits).
  rpc GetRobotModel(RobotModelRequest) returns (stream RobotModelChunk);
}

message StatusRequest {}

message Time {
  int32 sec = 1;
  uint32 nanosec = 2;
}

message StatusFieldMeta {
  enum StatusFieldType {
    STATUS_FIELD_TYPE_FLOAT = 0;
    STATUS_FIELD_TYPE_TEXT = 1;
  }

  // Stable identifier for this field.
  string id = 1;

  // Unit string for display (e.g., "V", "%", "Hz").
  string unit = 2;

  // Optional value type. When omitted, clients should assume FLOAT.
  optional StatusFieldType type = 6;

  // Optional ranges (display / validation only).
  optional float min = 3;
  optional float max = 4;

  // Optional target value (e.g., target Hz for rate fields).
  optional float target = 5;
}

message StatusFieldValue {
  string id = 1;
  float value = 2;

  // Optional textual value for TEXT-typed fields.
  optional string text = 4;

  // Timestamp of the sample in ROS time (prefers message header stamp; falls back to node clock).
  Time stamp = 3;
}

// Returned by GetStatus (includes metadata and values).
message StatusSnapshot {
  Time stamp = 1; // ROS time when the snapshot was assembled.
  uint64 seq = 2;

  // Optional wall-clock timestamp (milliseconds since Unix epoch).
  optional int64 wall_time_unix_ms = 3;

  repeated StatusFieldMeta fields = 4;
  repeated StatusFieldValue values = 5; // Only non-stale values.

  // Session context (best-effort; may be empty if the launcher didn't set it).
  string current_launch_ref = 6;
  string stack = 7;
  string fixed_frame = 8;
}

// Streamed status updates (values only).
message StatusUpdate {
  Time stamp = 1; // ROS time when the snapshot was assembled.
  uint64 seq = 2;

  // Optional wall-clock timestamp (milliseconds since Unix epoch).
  optional int64 wall_time_unix_ms = 3;

  repeated StatusFieldValue values = 4; // Only non-stale values.

  // Session context (best-effort; may be empty if the launcher didn't set it).
  string current_launch_ref = 5;
  string stack = 6;
  string fixed_frame = 7;
}

message RobotStateRequest {}

message LidarRequest {}

message MapRequest {}

message RobotModelRequest {}

message Pose3D {
  // Frame in which this pose is expressed (e.g. "odom", "map").
  string frame_id = 1;

  // Translation in meters.
  double x = 2;
  double y = 3;
  double z = 4;

  // Unit quaternion.
  double qx = 5;
  double qy = 6;
  double qz = 7;
  double qw = 8;
}

message JointAngle {
  string joint_name = 1;
  double position_rad = 2;
}

message RobotStateUpdate {
  // Unix epoch time in milliseconds when this snapshot was produced.
  int64 timestamp_unix_ms = 1;

  // Monotonic snapshot sequence number (starts at 1).
  uint64 seq = 2;

  // Single authoritative pose for UI rendering, expressed in the bridge-chosen fixed frame.
  // NOTE: Field number 3 intentionally matches the previous pose_odom field for wire compatibility.
  Pose3D pose = 3;

  // Reserved: previous optional pose_map field.
  reserved 4;

  // Wheel joint angles (positions) in radians.
  // Always present for configured wheel joints; defaults to 0 when unseen.
  repeated JointAngle wheel_angles = 5;
}

message RobotModelMeta {
  // Hash of the GLB payload (sha256 hex).
  string sha256 = 1;

  // Total GLB size in bytes.
  uint64 size_bytes = 2;

  // Configured wheel joints used by StreamRobotState.
  repeated string wheel_joint_names = 3;

  // Frames used by StreamRobotState.
  string odom_frame = 4;
  string base_frame = 5;
  string map_frame = 6;
}

message RobotModelChunk {
  reserved 1;

  // Raw GLB bytes.
  bytes chunk = 2;

  // Chunk index starting at 0.
  uint32 chunk_index = 3;
}

message LidarUpdate {
  // Unix epoch time in milliseconds when this snapshot was produced.
  int64 timestamp_unix_ms = 1;

  // Monotonic snapshot sequence number (starts at 1).
  uint64 seq = 2;

  // Frame in which the scan is expressed (e.g. "laser_link").
  string frame_id = 3;

  // Start angle of the scan in radians.
  float angle_min = 4;

  // Angular distance between measurements in radians.
  float angle_increment = 5;

  // Minimum range value in meters (values below are invalid).
  float range_min = 6;

  // Maximum range value in meters (values above are invalid).
  float range_max = 7;

  // Range data in meters. Length = floor((angle_max - angle_min) / angle_increment) + 1.
  // Invalid readings are represented as Inf (no return) or values outside [range_min, range_max].
  repeated float ranges = 8;
}

message MapUpdate {
  // Unix epoch time in milliseconds when this snapshot was produced.
  int64 timestamp_unix_ms = 1;

  // Monotonic snapshot sequence number (starts at 1).
  uint64 seq = 2;

  // Frame in which the map is expressed (typically "map").
  string frame_id = 3;

  // Map resolution (meters per pixel).
  float resolution_m_per_px = 4;

  // Map dimensions in pixels.
  uint32 width = 5;
  uint32 height = 6;

  // Origin pose of the map.
  Pose3D origin = 7;

  // Grayscale PNG-encoded occupancy image.
  // Convention: 0=occupied, 255=free, 127=unknown.
  bytes png = 8;
}
